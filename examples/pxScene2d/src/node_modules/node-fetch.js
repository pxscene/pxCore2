'use strict';

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name)
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value)
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift()
      return {done: value === undefined, value: value}
    }
  }

  return iterator
}

function Headers(headers) {
  this.map = {}

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value)
    }, this)
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1])
    }, this)
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name])
    }, this)
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name)
  value = normalizeValue(value)
  var oldValue = this.map[name]
  this.map[name] = oldValue ? oldValue + ', ' + value : value
}

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)]
}

Headers.prototype.get = function(name) {
  name = normalizeName(name)
  return this.has(name) ? this.map[name] : null
}

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
}

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value)
}

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this)
    }
  }
}

Headers.prototype.keys = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push(name)
  })
  return iteratorFor(items)
}

Headers.prototype.values = function() {
  var items = []
  this.forEach(function(value) {
    items.push(value)
  })
  return iteratorFor(items)
}

Headers.prototype.entries = function() {
  var items = []
  this.forEach(function(value, name) {
    items.push([name, value])
  })
  return iteratorFor(items)
}

function Body() {
  this._initBody = function(body) {
    this._bodyInit = body
    this._bodyText = body
  }

  this.text = function() {
    return Promise.resolve(this._bodyText)
  }

  this.json = function() {
    try {
     return this.text().then(JSON.parse)
    }
    catch(e) {
      // print exception and problematic message causing exception
      console.error(e);
      console.error(this._bodyText);
      return {}
    }
  }

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

function normalizeMethod(method) {
  var upcased = method.toUpperCase()
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {}
  var body = options.body

  if (input instanceof Request) {
    this.url = input.url
    if (!options.headers) {
      this.headers = new Headers(input.headers)
    }
    this.method = input.method
    if (!body && input._bodyInit != null) {
      body = input._bodyInit
    }
  } else {
    this.url = String(input)
  }

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers)
  }
  this.method = normalizeMethod(options.method || this.method || 'GET')

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body)
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
}

Body.call(Request.prototype)

function Response(bodyInit, options) {
  if (!options) {
    options = {}
  }

  this.type = 'default'
  this.status = options.status === undefined ? 200 : options.status
  this.ok = this.status >= 200 && this.status < 300
  this.statusText = 'statusText' in options ? options.statusText : 'OK'
  this.headers = new Headers(options.headers)
  this.url = options.url || ''
  this._initBody(bodyInit)
}

Body.call(Response.prototype)

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
}

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''})
  response.type = 'error'
  return response
}

var redirectStatuses = [301, 302, 303, 307, 308]

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
}

function fetch(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    let compress = init !== undefined && typeof init.compress === 'boolean' ? init.compress : true;
    let proto = /(.+:)\/\/.+/g.exec(request.url)[1];
    let host = /.+:\/\/(.+)/g.exec(request.url)[1];

    let proxyServer = "";
    if (global && global.sparkQueryParams && global.sparkQueryParams.sparkProxyServer) {
      proxyServer = global.sparkQueryParams.sparkProxyServer;
    }

    let xhr = sparkHttp({
      headers: request.headers.map,
      compress: compress,
      protocol: proto,
      host: host,
      method: request.method,
      proxy: proxyServer
    }, response => {
      const code = [];
      response.on('data', data => code.push(Buffer.from(data)));
      response.on('end', () => {
        let body = Buffer.concat(code);
        let opt = {
          status: response.statusCode,
          statusText: response.message,
          headers: response.headers
        };
        resolve(new Response(body, opt));
      });
      response.on('dataAndEnd', data => {
        code.push(Buffer.from(data));
        let body = Buffer.concat(code);
        let opt = {
          status: response.statusCode,
          statusText: response.message,
          headers: response.headers
        };
        resolve(new Response(body, opt));
      });
      response.on('error', errStr => reject(new Error(errStr)));
    });

    xhr.on('error', errStr => reject(new Error(errStr)));
    if (request._bodyText)
      xhr.write(request._bodyText);
    xhr.end();
  })
}

function fastFetch(localGlobal, input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init)

    let compress = typeof init.compress === 'boolean' ? init.compress : true;
    let proto = /(.+:)\/\/.+/g.exec(request.url)[1];
    let host = /.+:\/\/(.+)/g.exec(request.url)[1];

    let xhr = localGlobal.sparkHttp({
      headers: request.headers.map,
      compress: compress,
      protocol: proto,
      host: host,
      method: request.method,
      delayReply:true
    }, response => {
      const code = [];
      response.on('data', data => code.push(Buffer.from(data)));
      response.on('end', () => {
        let body = Buffer.concat(code);
        let opt = {
          status: response.statusCode,
          statusText: response.message,
          headers: response.headers
        };
        resolve(new Response(body, opt));
      });
      response.on('dataAndEnd', data => {
        let result = {responseData: data, statusCode: response.statusCode};
        resolve(result);
      });
      response.on('error', errStr => reject(new Error(errStr)));
    });

    xhr.on('error', errStr => reject(new Error(errStr)));
    if (request._bodyText)
      xhr.write(request._bodyText);
    xhr.end();
  })
}

fetch.Headers = Headers;
fetch.Request = Request;
fetch.Response = Response;

module.exports = fetch;
module.exports.fastFetch = fastFetch;
